- [235. Lowest Common Ancestor of a Binary Search Tree](https://github.com/yankun-song/leetcode/blob/main/Solutions/0235.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree.md)


  If the tree is a BST, then it's quite easy to use divide&conquer to solve this recursively. 
  
  We can know whether the target nodes are on the left or right tree easily, by comparing its value with the root value.
  
 - [236. Lowest Common Ancestor of a Binary Tree](https://github.com/yankun-song/leetcode/blob/main/Solutions/0236.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree.md)
  
  We traverse the whole tree once. For each root node, we check if the two targets are on different branches. If so, it is the result.
  
  - [1644. Lowest Common Ancestor of a Binary Tree II](https://github.com/yankun-song/leetcode/blob/main/Solutions/1644.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree%20II.md)
  
  The same as 236.
  
  - [1650. Lowest Common Ancestor of a Binary Tree III](https://github.com/yankun-song/leetcode/blob/main/Solutions/1650.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree%20III.md)
  
  We will always go up, this is actually a linked list problem.
