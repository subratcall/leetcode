本题的关键还是在于怎么去重。


## 解法1 Hash table
TC: O(n^2)
SC: O(n)

去重办法，需要同时满足以下几个条件：
1. num[i] <= num[j] <= num[k]
2. 对于i/j每个position，只在每个数字第一次出现时考虑，后续如果再有出现，直接跳过。即如果已经考虑过第一个位置是-2的情况，下次-2再出现在第一个位置，则直接不考虑。

怎么知道符合条件：
target = 0 - num[i] - num[j]
target要在num中，且个数足够用。
比如[-2, 1, 1]这种，target=1，确实存在，但是如果只出现过1次，那是不符合的。


```
class Solution:
    def threeSum(self, A):
        '''
        :type A: list of int
        :rtype: list of list of int
        '''
        import collections
        counter = collections.Counter(A)
        A.sort()
        
        res = []

        for i in range(0, len(A)):
            if i > 0 and A[i] == A[i - 1]:
                continue
            for j in range(i + 1, len(A)):
                if j > i + 1 and A[j] == A[j - 1]:
                    continue
                # check the occurance of A[k]
                target = -A[i] - A[j]
                
                #计算需要的occurance这里要注意加括号，否则优先级会出现问题
                if target >= A[j] and target in counter \
                    and counter[target] >= 1 + (target == A[i]) + (target == A[j]):
                    res.append([A[i], A[j], target])

        return res

```
