## 解法1： Brute Force
一步步枚举，直到到达现在的情况  
TC: O(n！) SC: O(1)

TC: O(n) SC: O(1)

```
class Solution:
    def nextPermutation(self, nums):
        '''
        :type nums: list of int
        :rtype: list of int
        '''
        n = len(nums) - 1
        p, prev = n - 1, n

        # 找到第一个非降序的位置
        # [x, 1, 1]这种情况就当成已经是最后一种可能了
        while p >= 0:
            if nums[p] >= nums[prev]:
                prev = p
                p -= 1
            else:
                break
            
        if p == -1:
            nums.reverse()
            return

        # 找到降序数组中，第一个比nums[p]大的数
        idx = -1
        while True:
            if nums[idx] > nums[p]:
                break
            else:
                idx -= 1
            
        # 交换nums[p], nums[idx]
        nums[p], nums[idx] = nums[idx], nums[p]

        #把原来那段降序数组倒序
        #这段可以用双指针法降低空间复杂度
        nums[p + 1:] = reversed(nums[p + 1:])

        
        
```
