## 解法： 二分

这题本身倒不算很难，大体思路是有的，难的是能bug-free地写出来。

先上自己写的代码。前半段套用二分模板，后半段类似于merge two sorted array。

中间出了几次错，循环条件还是很容易出错的。
```
class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        left, right = 0, len(arr)
        while left + 1 < right:
            mid = (left + right) // 2
            if arr[mid] < x:
                left = mid
            else:
                right = mid
                       
        while k and left >=0 and right < len(arr):
            direction, num = self.findCloser(x, arr[left], arr[right])
            if direction == 1:
                left -= 1
            else:
                right += 1
            k -= 1
            
        if k and left >= 0:
            left -= k
        if k and right < len(arr) - 1:
            right += k
            
        return arr[left + 1: right]
            
        
    def findCloser(self, target, x, y):
        if abs(target - x) < abs(target - y):
            return (1, x)
        elif abs(target - x) > abs(target - y):
            return (2, y)
        return (1, x) if x < y else (2, y)
```

后面这段是令狐冲的代码。他给的建议是，如果一个函数的长度在20
