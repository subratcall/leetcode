## 解法1: Hash map
TC: O(N). SC:O(N)

本题的难点在于，在新建Node的过程中，它的random可能还没有被复制出来，或者复制出来了你也对应不上。

但是本题有个明显的特点，就是被复制的node和新的node有着一一对应的关系。想到“对应”，就应该能想到用map。

A'.random = y(A.random)

y(A).random = y(A.random)

用以上对应关系的时候，要注意map的key是不是空。如果是空，要另外处理。
```
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""

class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head:
            return head
        
        mapping = {}
        curr = head
        while curr:
            new_node = Node(curr.val)
            mapping[curr] = new_node
            curr = curr.next
            
        curr = head
        while curr:
            if curr.next:
                mapping[curr].next = mapping[curr.next]
            else:
                mapping[curr].next = None
            if curr.random:
                mapping[curr].random = mapping[curr.random]
            else:
                mapping[curr].random = None
                
            curr = curr.next
        
        return mapping[head]
```
