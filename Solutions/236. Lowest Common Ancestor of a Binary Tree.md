## 解法1: Recursion

## 解法2: Find paths

要找p, q的LCA，可以先分别找每个node的ancestors，记录下来。

然后找最小的公共祖先，也有两个方向。一种是从顶向下，看在哪个点分叉了。另外一种是从下向上，任选一个node，从它最近的ancestor开始，看是否属于另一个node的ancestor。这两种实现都不难。

所以问题还是在于怎么找到从root到target的这条path。可以用recursion和backtracking来写。前者更好写，但是消耗的资源更多（因为要重复地复制）；后者理解之后也不算难写。还是要熟练。


- pathFinder用回溯法来写。执行时间80-90ms.
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        p_paths = []
        self.pathFinder(root, p, [], p_paths)
        q_paths = []
        self.pathFinder(root, q, [], q_paths)
        
        p_path, q_path = p_paths[0], q_paths[0]
        q_set = set(q_path)
        
        for i in range(-1, -len(p_path) - 1, -1):
            if p_path[i] in q_set:
                return p_path[i]
        
    def pathFinder(self, root, target, visited, res):
        visited.append(root)
        if root == target:
            res.append(visited[:])
        if root.left:
            self.pathFinder(root.left, target, visited, res)
            visited.pop()
        if root.right:
            self.pathFinder(root.right, target, visited, res)
            visited.pop()

```

- pathFinder用递归来写，执行时间900ms.

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        p_path = self.pathFinder(root, p)
        q_path = self.pathFinder(root, q)
        
        q_set = set(q_path)
        
        for i in range(-1, -len(p_path) - 1, -1):
            if p_path[i] in q_set:
                return p_path[i]
        
    def pathFinder(self, root, target):
        if not root:
            return []
        if root == target:
            return [root]
      
        res_left = self.pathFinder(root.left, target)
        res_right = self.pathFinder(root.right, target)
        
        res = []
        if res_left:
            res.append(root)
            res += res_left
        if res_right:
            res.append(root)
            res += res_right
        return res
```

做这题的时候，对写回溯的印象更深了。

课上讲过，分治法，是交给小弟任务，自己汇总结果。遍历法，是一个小人用记事本走遍所有节点，在出现指定的情况时，把当时的状态保存下来。

所以在写遍历法的helper function的时候，要准备两个本子。一个是visited，实时更新此刻的状态。另一个是res，用于保存需要的结果。

另外一个坑，是res好像必须得设置为list，并且在出现需要的结果时，往里面append。那像这题，如果确定只有一个结果，可不可以直接写成res = visited[:]呢？

答案是不可以。原因可以通过下面这个例子说明：

```
def fun(nums):
    nums = [0]

a = [1,2]
fun(a)
print(a)
```
可以把variable理解为信封，a信封和nums信封都对应着不同的地址，这些地址上都盖了房子。

上面代码的结果是[1,2].因为在调用fun函数时，a和nums都指向的是[1,2]所对应的内存地址。而后来nums被指向了[0]，等于信封上的地址被换了。修改的只是信封所代表的地址，地址上的房屋并没有改动。

此时a的指向并没有变，还是指向原来的房子，且房子并没有被动过。

而如果是nums.append(0)，那么nums指向的地址上的房子就被修整了，当通过a去找对应的房子时，也会发现房子的变化。因为这两个信封一直指向了同一个房子。

所以回到本题，在helper function内部修改res的指向，并不能实现我们所要的结果，因为函数内部的res只是形参。只有把结果append进去，才是真的记下了。






