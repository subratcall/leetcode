## 解法1: 
TC: O(N) SC: O(N)

题目要求unique pair，不能有重复的，那就比较容易想到先通过set()进行去重。但是k=0时这个办法行不通，所以要单独处理。

当k不为0时，问题相对简单一些（这个子问题就是lintcode1796）。每个pair中两个数都是先后出现的，我们只在前面那个数已经出现过，后面这个数刚出现的时候计数。有两种可能，+-k。这里正好也有个隐含条件k不为0（否则会多记一次）。
```
class Solution:
    def findPairs(self, nums: List[int], k: int) -> int:
        # k = 0
        if k == 0:
            count = 0
            frequency = collections.Counter(nums)
            for n in frequency.values():
                if n > 1:
                    count += 1
            return count
        
        # k > 0 
        visited = set()
        nums = set(nums)
        count = 0
        for num in nums:
            if num + k in visited:
                count += 1
            if num - k in visited:
                count += 1
            visited.add(num)
        return count
```
